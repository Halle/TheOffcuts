

(function(w, d) {
    'use strict';

    if(w.hljs) {
        w.hljs.highlightLinesAll = highlightLinesAll;
        w.hljs.highlightLinesElement = highlightLinesElement;

        /* deprecated */
        w.hljs.initHighlightLinesOnLoad = initHighlightLinesOnLoadWithDeprecated;
        w.hljs.highlightLinesCode = highlightLinesCodeWithDeprecated;
    }

    function highlightLinesAll(options) {
        for(var i = 0; i < options.length; ++i) {
            for(var option of options[i]) {
                --option.start;
                --option.end;
            }
        }
        initHighlightLinesOnLoad(options);
    }

    var initHighlightLinesOnLoadWithDeprecatedCalled = false;
    function initHighlightLinesOnLoadWithDeprecated(options) {
        if(!initHighlightLinesOnLoadWithDeprecatedCalled) {
            console.log('hljs.initHighlightLinesOnLoad is deprecated. Please use hljs.highlightLinesAll')
            initHighlightLinesOnLoadWithDeprecatedCalled = true;
        }
        initHighlightLinesOnLoad(options)
    }

    function initHighlightLinesOnLoad(options) {
        function callHighlightLinesCode() {
            var codes = d.getElementsByClassName('hljs');
            for(var i = 0; i < codes.length; ++i) {
                highlightLinesCode(codes[i], options[i]);
            }
        }

        if(d.readyState !== 'loading') {
            callHighlightLinesCode();
        }
        else {
            w.addEventListener('DOMContentLoaded', function() {
                callHighlightLinesCode();
            });
        }
    }

    function highlightLinesElement(code, options, has_numbers) {
        for(var option of options) {
            --option.start;
            --option.end;
        }
        highlightLinesCode(code, options, has_numbers);
    }

    var highlightLinesCodeWithDeprecatedCalled = false;
    function highlightLinesCodeWithDeprecated(code, options, has_numbers) {
        if(!highlightLinesCodeWithDeprecatedCalled) {
            console.log('hljs.highlightLinesCode is deprecated. Please use hljs.highlightLinesElement')
            highlightLinesCodeWithDeprecatedCalled = true;
        }
        highlightLinesCode(code, options, has_numbers)
    }

 
    function highlightLinesCode(code, options, has_numbers) {
        function highlightLinesCodeWithoutNumbers() {
            code.innerHTML = code.innerHTML.replace(/([ \S]*\n|[ \S]*$)/gm, function(match) {
                    return '<div class="highlight-line">' + match + '</div>';
                    });

            if(options === undefined) {
                return;
            }

            var paddingLeft = parseInt(window.getComputedStyle(code).paddingLeft);
            var paddingRight = parseInt(window.getComputedStyle(code).paddingRight);

            var lines = code.getElementsByClassName('highlight-line');
            var scroll_width = code.scrollWidth;
            for(var option of options) {
                for(var j = option.start; j <= option.end; ++j) {
                    lines[j].style.backgroundColor = option.color;
                    lines[j].style.minWidth = scroll_width - paddingLeft - paddingRight + 'px';
                }
            }
        }
        
        // https://stackoverflow.com/a/41391872/119717
        
		function wrapAll(nodes, wrapper) {
			// Cache the current parent and previous sibling of the first node.
			var parent = nodes[0].parentNode;
			var previousSibling = nodes[0].previousSibling;

			// Place each node in wrapper.
			//  - If nodes is an array, we must increment the index we grab from 
			//    after each loop.
			//  - If nodes is a NodeList, each node is automatically removed from 
			//    the NodeList when it is removed from its parent with appendChild.
			for (var i = 0; nodes.length - i; wrapper.firstChild === nodes[0] && i++) {
				wrapper.appendChild(nodes[i]);
			}

			// Place the wrapper just after the cached previousSibling,
			// or if that is null, just before the first child.
			var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
			parent.insertBefore(wrapper, nextSibling);

			return wrapper;
		}

        function highlightLinesCodeWithNumbers() {
        
            var tables = code.getElementsByTagName('table');
            if(tables.length == 0) {
                if(count-- < 0) {
                    clearInterval(interval_id);
                    highlightLinesCodeWithoutNumbers();
                }
                return;
            }

            clearInterval(interval_id);
            
			// we are going to put the highlighted lines in a tbody so we can work with them at the box level. 
			// We will also put unhighlighted in their own tbody and we will get rid of the original unused tbody.
            
            var table = tables[0];

            table.style.width = '100%';
            var hljs_ln_numbers = table.getElementsByClassName('hljs-ln-numbers');
            for(var hljs_ln_number of hljs_ln_numbers) {
                hljs_ln_number.style.width = '2em';
            }

            if(options === undefined) {
                return;
            }
            
            var lines = code.getElementsByTagName('tr');
            var trs = Array.from(lines); // We need to do some of this on an array rather than a nodelist.
			var startnumber = 0 // track unhighlighted beginning line numbers

            for(var option of options) {
                for(var j = option.start; j <= option.end; ++j) {
                if (j == option.start) {
					lines[j].classList.add('firsthighlightedline') // class the first highlighted tr just in case of design wishes     
				}
				if (j == option.end) {
					lines[j].classList.add('lasthighlightedline') // class the last highlighted tr just in case of design wishes     
				}
                if (j != option.end && j != option.start) {
	                lines[j].classList.add('middlehighlightedline') // class the middle highlighted trs
                }				
                    lines[j].classList.add('highlightedline') // shared class for every highlighted tr           
                }

				var nohighlightslice = trs.slice((startnumber), (option.start)) // These are the unhighlighted lines before and after the first highlight
				var tbody = document.createElement('tbody'); // Put them in their own tbody
				tbody.classList.add('nohighlighttbody')
				wrapAll(nohighlightslice, tbody);

				var highlightslice = trs.slice((option.start), option.end + 1) // these are the highlighted lines
				var tbody = document.createElement('tbody'); // Put them in their own tbody
				tbody.classList.add('highlighttbody')
				wrapAll(highlightslice, tbody);
			
				startnumber = option.end + 1 // Remember the next starting point for unhighlighted line
            }

			var lastnohighlightslice = trs.slice((startnumber), trs.length) // These are the last unhighlighted lines
			var tbody = document.createElement('tbody'); // Put them in their own tbody
			tbody.classList.add('nohighlighttbody')
			wrapAll(lastnohighlightslice, tbody);
			
			var tbodies = document.getElementsByTagName("tbody"); // We now have a bunch of nested tbodies, we want to move them all to the same level
			for(var i = 0, max = tbodies.length; i < max; i++) {
				if(tbodies[i].className == "highlighttbody" || tbodies[i].className == "nohighlighttbody") { // Move new tbodies to the same level as the original single tbody
					tbodies[i].parentNode.before(tbodies[i]);
				}
			}
			for(var i = 0, max = tbodies.length; i < max; i++) { // second loop because we have to guarantee that operations on the new tbodies are done before attempting this.
				if(tbodies[i].className != "highlighttbody" && tbodies[i].className != "nohighlighttbody") {
					tbodies[i].remove(); // Find the original tbody, which is now empty (or should be!) and remove it.
				}
			} // Now we have converted from a single tbody to several at the same level, which either contain highlighted lines or non-highlighted lines.
        }

        if(hljs.hasOwnProperty('initLineNumbersOnLoad') && has_numbers !== false) {
            var count = 100;
            var interval_id = setInterval(highlightLinesCodeWithNumbers, 100);
            return;
        }

        highlightLinesCodeWithoutNumbers();
    }

}(window, document));
